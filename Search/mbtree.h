/*M////////////////////////////////////////////////////////////////////////////
//  m阶b树相关查找 
//
//*/

#ifndef MBTREE_H
#define MBTREE_H

#define  M  3

typedef	int  Boolean; 
typedef int  KeyType;

// m阶b树结构体定义 
typedef	struct MBTNode 
{
	struct MBTNode	* 	parent;
	struct MBTNode  * 	ptr[M+1];
	int  				keynum;
	KeyType  			key[M+1];
} MBTNode, *MBTree;

/*****************************************************************************
 *    在mbp->key[ipos +1]处插上key, 在mbp->ptr[ipos+1]处插上rp               * 
 *****************************************************************************/
void insert(MBTree mbp,	int ipos, KeyType key, MBTree rp);

/*****************************************************************************
 *     B_树的分裂过程                                                        *
 *****************************************************************************/
void split(MBTree oldp, MBTree * newp);

/*****************************************************************************
 *     在mbt指向的结点中，寻找小于等于key的最大关键字序号                    *
 *****************************************************************************/
int search(MBTree mbt, KeyType key );

/*****************************************************************************
 *     在m阶B_树t中插入k：如果mbt=NULL，则生成初始根（此时q=NULL,i=0）；     *
 *     否则q指向某个最下层非终端结点，k应插在该结点中q->key[i+1]处，         *
 *     插入后如果q->keynum>m-1，则进行分裂处理                               *
 *****************************************************************************/
void insertmbtree(MBTree * mbt, KeyType k, MBTree q, int  i);

/*****************************************************************************
 *     创建一颗m阶b-树                                                       *
 *****************************************************************************/
void CreateMBTree(MBTree * mbt, int len, KeyType key[]);

/*****************************************************************************
 *     在根为mbt的B_树中查找关键字k，如果查找成功，                          *
 *     则将所在结点地址放入np，将结点内位置序号放入pos，并返回true；         *
 *     否则，将k应被插入的结点地址放入np，将结点内应插位置序号放入pos，      *
 *     并返回false                                                           *
 *****************************************************************************/
Boolean SearchMBTree(MBTree mbt, KeyType k, MBTree * np, int * pos);

#endif // END MBTREE_H
